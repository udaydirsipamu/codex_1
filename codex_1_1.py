# -*- coding: utf-8 -*-
"""Codex_1_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19iykVtko2PPAl3kXK3tb6R9aS9HNGxu3
"""

import pandas as pd
import numpy as np
df=pd.read_csv('ipl.csv')
df.head()

df.info()

df['Date']=pd.to_datetime(df['Date'])

df.info()

df.drop_duplicates(inplace=True)

df.head()

df.info()

df.columns

num_cols = df.select_dtypes(include=["number"]).columns
df[num_cols] = df[num_cols].fillna(0)

num_cols

cat_cols = df.select_dtypes(include=["object"]).columns
df[cat_cols] = df[cat_cols].fillna("Unknown")

df.info()

cols_to_drop = ["match_id", "extras_type", "fielder", "player_of_match"]
df.drop(columns=cols_to_drop, inplace=True, errors='ignore')

df.head()

df.info()

import matplotlib.pyplot as plt
import seaborn as sns

outlier_columns = ["total_runs", "bowler_wicket", "6s", "4s"]
plt.figure(figsize=(12, 6))
sns.boxplot(data=df[outlier_columns])
plt.title("Box Plot of Key Numerical Columns")
plt.show()

num_cols

#univariate
def univariate_analysis(numerical_data):
  for col_name in numerical_data:
    print("*"*10, col_name, "*"*10)
    print(numerical_data[col_name].agg(['min','max','mean','median','std','skew','kurt']))
    print()

univariate_analysis(df[num_cols])

def disc_univar_analysis(discrete_data):
  for col_name in discrete_data:
    print("*"*10, col_name, "*"*10)
    print(discrete_data[col_name].agg(['count','nunique','unique']))
    print("Value Counts: \n",discrete_data[col_name].value_counts(normalize=True))
    print()

cat_cols

df["total_runs"].unique()

avg_runs_per_over = df.groupby(df["over"] + 1)["total_runs"].mean()*100
total_wickets = df.groupby("bowler")["bowler_wicket"].sum().sort_values(ascending=False).head(10)

avg_runs_per_over

total_wickets

#Average runs per over
plt.figure(figsize=(10, 5))
sns.barplot(x=avg_runs_per_over.index, y=avg_runs_per_over.values, palette="viridis")
plt.xlabel("Over")
plt.ylabel("Average Runs")
plt.title("Average Runs per Over in IPL")
plt.show()

#avg runs per over
wickets_per_over = df.groupby(df["over"] + 1)["bowler_wicket"].sum()
plt.figure(figsize=(10, 5))
sns.barplot(x=wickets_per_over.index, y=wickets_per_over.values, palette="Reds")
plt.xlabel("Over")
plt.ylabel("Total Wickets")
plt.title("Total Wickets per Over in IPL")
plt.show()
avg_runs_per_over = df.groupby(df["over"] + 1)["total_runs"].mean() * 100
total_wickets = df.groupby("bowler")["bowler_wicket"].sum().sort_values(ascending=False).head(10)

#Top 10 Wicket-Taking Bowlers
plt.figure(figsize=(12, 6))
sns.barplot(x=total_wickets.values, y=total_wickets.index, palette="magma")
plt.xlabel("Total Wickets")
plt.ylabel("Bowler")
plt.title("Top 10 Wicket-Taking Bowlers in IPL")
plt.show()

#Total Runs vs Over
plt.figure(figsize=(10, 6))
sns.scatterplot(x=df["over"]+1, y=df["total_runs"]*100, alpha=0.3, color="blue")
plt.xlabel("Over")
plt.ylabel("Total Runs")
plt.title("Scatter Plot: Total Runs vs Over")
plt.show()

#Correlation between numerical features
plt.figure(figsize=(12, 6))
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap="coolwarm", linewidths=0.5)
plt.title("Heatmap of Correlations Between Numerical Features")
plt.show()

#Analysis
# Runs Per Over:
# Runs increase as the innings progress.
# Highest scoring overs are death overs (16-20).

# Wickets Taken:
# Some bowlers dominate wicket-taking consistently.
# Death overs see more wickets due to aggressive batting.

# Scatter Plot (Total Runs vs. Over):
# Runs are more evenly distributed in the first 10 overs.
# In the final overs, there's a wider spread due to aggressive hitting.

# Heatmap (Correlation Analysis):
# Total runs strongly correlate with 6s and 4s.
# A slight correlation exists between wickets and overs, indicating more wickets fall later in the innings.

nums=[3,4,5]
sum(num>0 for num in nums)

#project-2

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

# Load dataset
df = pd.read_csv("data.csv")

# Step 1: Select Relevant Features and Target
X = df.drop(columns=['price', 'date', 'street', 'city', 'statezip', 'country'])
y = df['price']

# Step 2: Split the Data into Training and Testing Sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Step 3: Preprocess the Data (Standardization)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Step 4: Train the Linear Regression Model
model = LinearRegression()
model.fit(X_train_scaled, y_train)

# Step 5: Evaluate Model Performance on Training Data
y_train_pred = model.predict(X_train_scaled)
train_mae = mean_absolute_error(y_train, y_train_pred)
train_rmse = mean_squared_error(y_train, y_train_pred) ** 0.5
train_r2 = r2_score(y_train, y_train_pred)

# Step 6: Evaluate Model Performance on Test Data
y_test_pred = model.predict(X_test_scaled)
test_mae = mean_absolute_error(y_test, y_test_pred)
test_rmse = mean_squared_error(y_test, y_test_pred) ** 0.5
test_r2 = r2_score(y_test, y_test_pred)

# Step 7: Print Results
print("Training Performance:")
print(f"MAE: {train_mae}, RMSE: {train_rmse}, R2 Score: {train_r2}")
print("\nTest Performance:")
print(f"MAE: {test_mae}, RMSE: {test_rmse}, R2 Score: {test_r2}")

# Step 8: Function to Predict House Price
def predict_house_price(input_features):
    """Predicts house price based on input features."""
    input_array = np.array(input_features).reshape(1, -1)  # Reshape for a single prediction
    input_scaled = scaler.transform(input_array)  # Apply scaling
    predicted_price = model.predict(input_scaled)[0]  # Predict
    return predicted_price

# Example Usage
example_house = X_test.iloc[0].tolist()  # Take first test sample as example
predicted_price = predict_house_price(example_house)
print(f"Predicted House Price: {predicted_price}")

df.head()

#project-3
import numpy as np

def get_matrix_input(name):
    rows = int(input(f"Enter the number of rows for {name}: "))
    cols = int(input(f"Enter the number of columns for {name}: "))

    print(f"Enter the elements of {name} row by row (space-separated):")
    matrix = []

    for i in range(rows):
        while True:
            rows = input().split()
            if len(rows) != cols:
                print(f"Invalid input! Expected {cols} elements but got {len(rows)}. Try again:")
                continue
            try:
                matrix.append(list(map(float, rows)))
                break
            except ValueError:
                print("Invalid input! Please enter numeric values only.")

    return np.array(matrix)

def display_matrix(matrix, name):
    print(f"{name}:\n{matrix}\n")

def matrix_operations():
    print("Matrix Operations Tool")
    while True:
        print("\nChoose an operation:")
        print("1. Addition")
        print("2. Subtraction")
        print("3. Multiplication")
        print("4. Transpose")
        print("5. Determinant")
        print("6. Exit")
        choice = input("Enter your choice (1-6): ")

        if choice in ['1', '2', '3']:
            A = get_matrix_input("Matrix A")
            B = get_matrix_input("Matrix B")
            if A.shape != B.shape and choice in ['1', '2']:
                print("Error: Matrices must have the same dimensions for addition or subtraction.")
                continue

            if choice == '1':
                result = A + B
                display_matrix(result, "Result (A + B)")
            elif choice == '2':
                result = A - B
                display_matrix(result, "Result (A - B)")
            elif choice == '3':
                if A.shape[1] != B.shape[0]:
                    print("Error: Number of columns of A must equal number of rows of B for multiplication.")
                    continue
                result = np.dot(A, B)
                display_matrix(result, "Result (A * B)")

        elif choice == '4':
            A = get_matrix_input("Matrix A")
            result = A.T
            display_matrix(result, "Transpose of A")

        elif choice == '5':
            A = get_matrix_input("Square Matrix A")
            if A.shape[0] != A.shape[1]:
                print("Error: Determinant can only be calculated for square matrices.")
                continue
            result = np.linalg.det(A)
            print(f"Determinant of A: {result}\n")

        elif choice == '6':
            print("Exiting the program.")
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 6.")

if __name__ == "__main__":
    matrix_operations()

#Write a program to filter the values from the array based on below mentioned conditions: Either value should be divisible by 5. (or) value should be an odd number and factor of 7.

import numpy as np
a=np.arange(1,100)
for i in a:
  if (i%5==0) or (i%2!=0 and i%7==0):
    print(i)

